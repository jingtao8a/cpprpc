#include <cpprpc/stub/ClientStubGenerator.hpp>

namespace CPPRPC {
std::string clientStubTemplate(
        const std::string& macroName,
        const std::string& stubClassName,
        const std::string& procedureDefinitions,
        const std::string& notifyDefinitions)
{
    std::string str = R"(
/*
 * This stub is generated by cpprpc, DO NOT modify it!
 */

#ifndef CPPRPC_[macroName]_HPP
#define CPPRPC_[macroName]_HPP

#include <cppjson/Value.hpp>

#include <cpprpc/utils.hpp>
#include <cpprpc/client/BaseClient.hpp>
#include <cppweb/Logger.hpp>
#include <cppweb/Singleton.hpp>

namespace CPPRPC {

static auto& logger = CPPWEB::Singleton<CPPWEB::Logger>::GetInstance();

class [stubClassName]: public CPPWEB::nocopyable{
public:
    [stubClassName](CPPWEB::EventLoop* loop, const CPPWEB::InetAddress& serverAddress):
            m_client(loop, serverAddress)
    {
        m_client.setConnectionCallback([this](const CPPWEB::TCPConnectionPtr& conn){
            if (conn->isConnected()) {
                INFO(logger, "connected");
                m_conn = conn;
                m_cb(m_conn);
            } else {
                INFO(logger, "disconnected");
                assert(m_conn != nullptr);
                m_cb(m_conn);
            }
        });
    }

    void start() { m_client.start(); }

    void setConnectionCallback(const CPPWEB::ConnectionCallback& cb) {
        m_cb = cb;
    }

    [procedureDefinitions]
    [notifyDefinitions]

private:
    CPPWEB::TCPConnectionPtr m_conn;
    CPPWEB::ConnectionCallback m_cb;
    BaseClient m_client;
};

}
#endif //CPPRPC_[macroName]_HPP
)";
    replaceAll(str, "[macroName]", macroName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[procedureDefinitions]", procedureDefinitions);
    replaceAll(str, "[notifyDefinitions]", notifyDefinitions);
    return str;
}

std::string procedureDefineTemplate(
        const std::string& serviceName,
        const std::string& procedureName,
        const std::string& procedureArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [procedureName]([procedureArgs] const ResponseCallback& cb)
{
    cppjson::Value params(cppjson::TYPE_OBJECT);
    [paramMembers]

    cppjson::Value call(cppjson::TYPE_OBJECT);
    call.addMember(cppjson::Value("jsonrpc"), cppjson::Value("2.0"));
    call.addMember(cppjson::Value("method"), cppjson::Value("[serviceName].[procedureName]"));
    call.addMember(cppjson::Value("params"), cppjson::Value(params));

    assert(m_conn != nullptr);
    m_client.sendCall(m_conn, call, cb);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[procedureArgs]", procedureArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string notifyDefineTemplate(
        const std::string& serviceName,
        const std::string& notifyName,
        const std::string& notifyArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [notifyName]([notifyArgs])
{
    cppjson::Value params(cppjson::TYPE_OBJECT);
    [paramMembers]

    cppjson::Value notify(cppjson::TYPE_OBJECT);
    notify.addMember(cppjson::Value("jsonrpc"), cppjson::Value("2.0"));
    notify.addMember(cppjson::Value("method"), cppjson::Value("[serviceName].[notifyName]"));
    notify.addMember(cppjson::Value("params"), cppjson::Value(params));
    assert(m_conn != nullptr);
    m_client.sendNotify(m_conn, notify);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[notifyArgs]", notifyArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string paramMemberTemplate(const std::string& paramName)
{
    std::string str = R"(
params.addMember(cppjson::Value("[paramName]"), cppjson::Value([paramName]));
)";
    replaceAll(str, "[paramName]", paramName);
    return str;
}

std::string argTemplate(
        const std::string& argName,
        cppjson::ValueType argType)
{
    std::string str = R"([argType] [argName])";
    auto typeStr = [=](){
        switch (argType) {
            case cppjson::TYPE_INT32:
                return "int32_t";
            case cppjson::TYPE_INT64:
                return "int64_t";
            case cppjson::TYPE_DOUBLE:
                return "double";
            case cppjson::TYPE_BOOL:
                return "bool";
            case cppjson::TYPE_STRING:
                return "std::string";
            case cppjson::TYPE_OBJECT:
            case cppjson::TYPE_ARRAY:
                return "cppjson::Value";
            default:
                assert(false && "bad arg type");
                return "bad type";
        }
    }();
    replaceAll(str, "[argType]", typeStr);
    replaceAll(str, "[argName]", argName);
    return str;
}

std::string ClientStubGenerator::genStub() {
    auto macroName = genMacroName();
    auto stubClassName = genStubClassName();
    auto procedureDefinitions = genProcedureDefinitions();
    auto notifyDefinitions = genNotifyDefinitions();

    return clientStubTemplate(macroName,
                              stubClassName,
                              procedureDefinitions,
                              notifyDefinitions);
}

std::string ClientStubGenerator::genStubClassName() {
    return m_serviceInfo.m_name + "ClientStub";
}

std::string ClientStubGenerator::genMacroName() {
    std::string result = m_serviceInfo.m_name;
    for (char& c: result)
        c = static_cast<char>(toupper(c));
    return result + "CLIENTSTUB";
}

std::string ClientStubGenerator::genProcedureDefinitions() {
    std::string result;
    auto& serviceName = m_serviceInfo.m_name;

    for (auto& r: m_serviceInfo.m_rpcReturn) {
        auto& procedureName = r.m_name;
        auto  procedureArgs = genGenericArgs(r, true);
        auto  paramMembers = genGenericParamMembers(r);

        auto str = procedureDefineTemplate(
                serviceName,
                procedureName,
                procedureArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

std::string ClientStubGenerator::genNotifyDefinitions() {
    std::string result;

    auto& serviceName = m_serviceInfo.m_name;

    for (auto& r: m_serviceInfo.m_rpcNotify) {
        auto& notifyName = r.m_name;
        auto notifyArgs = genGenericArgs(r, false);
        auto paramMembers = genGenericParamMembers(r);

        auto str = notifyDefineTemplate(
                serviceName,
                notifyName,
                notifyArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

template<typename Rpc>
std::string ClientStubGenerator::genGenericArgs(const Rpc& r, bool appendComma) {
    std::string result;
    bool first = true;
    for (auto& p: r.m_params.getObject()) {
        std::string one = argTemplate(p.m_key.getString(), p.m_value.getType());
        if (first) {
            first = false;
        }
        else {
            result.append(", ");
        }
        result.append(one);
    }
    if (appendComma && !first)
        result.append(",");
    return result;
}

template<typename Rpc>
std::string ClientStubGenerator::genGenericParamMembers(const Rpc& r) {
    std::string result;
    for (auto& p: r.m_params.getObject()) {
        std::string one = paramMemberTemplate(p.m_key.getString());
        result.append(one);
    }
    return result;
}

}