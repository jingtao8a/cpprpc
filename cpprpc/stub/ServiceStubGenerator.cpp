#include "ServiceStubGenerator.hpp"

namespace CPPRPC {
std::string serviceStubTemplate(
        const std::string& macroName,
        const std::string& userClassName,
        const std::string& stubClassName,
        const std::string& serviceName,
        const std::string& stubProcedureBindings,
        const std::string& stubProcedureDefinitions)
{
    std::string str =
R"(
/*
 * This stub is generated by cpprpc, DO NOT modify it!
 */
#ifndef CPPRPC_[macroName]_H
#define CPPRPC_[macroName]_H

#include <cppjson/src/Value.h>

#include <../src/util.h>
#include <../src/server/RpcServer.h>
#include <../src/server/RpcService.h>

class [userClassName];

namespace jrpc
{

template <typename S>
class [stubClassName]: noncopyable
{
protected:
    explicit
    [stubClassName](RpcServer& server)
    {
        static_assert(std::is_same_v<S, [userClassName]>,
                      "derived class name should be '[userClassName]'");

        auto service = new RpcService;

        [stubProcedureBindings]

        server.addService("[serviceName]", service);
    }

    ~[stubClassName]() = default;

private:
    [stubProcedureDefinitions]

private:
    S& convert()
    {
        return static_cast<S&>(*this);
    }
};

}

#endif //CPPRPC_[macroName]_H
)";
    replaceAll(str, "[macroName]", macroName);
    replaceAll(str, "[userClassName]", userClassName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[stubProcedureBindings]", stubProcedureBindings);
    replaceAll(str, "[stubProcedureDefinitions]", stubProcedureDefinitions);
    return str;
}


std::string stubProcedureBindTemplate(
        const std::string& procedureName,
        const std::string& stubClassName,
        const std::string& stubProcedureName,
        const std::string& procedureParams)
{
    std::string str =
R"(
service->addProcedureReturn("[procedureName]", new ReturnProcedure(
        std::bind(&[stubClassName]::[stubProcedureName], this, _1, _2)
        [procedureParams]
));
)";

    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[stubProcedureName]", stubProcedureName);
    replaceAll(str, "[procedureParams]", procedureParams);
    return str;
}

std::string stubNotifyBindTemplate(
        const std::string& notifyName,
        const std::string& stubClassName,
        const std::string& stubNotifyName,
        const std::string& notifyParams)
{
    std::string str =
R"(
service->addProcedureNotify("[notifyName]", new ProcedureNotify(
        std::bind(&[stubClassName]::[stubNotifyName], this, _1)
        [notifyParams]
));
)";

    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[stubNotifyName]", stubNotifyName);
    replaceAll(str, "[notifyParams]", notifyParams);
    return str;
}

std::string stubProcedureDefineTemplate(
        const std::string& paramsFromJsonArray,
        const std::string& paramsFromJsonObject,
        const std::string& stubProcedureName,
        const std::string& procedureName,
        const std::string& procedureArgs)
{
   std::string str =
R"(void [stubProcedureName](json::Value& request, const RpcDoneCallback& done)
{
    auto& params = request["params"];

    if (params.isArray()) {
        [paramsFromJsonArray]
        convert().[procedureName]([procedureArgs] UserDoneCallback(request, done));
    }
    else {
        [paramsFromJsonObject]
        convert().[procedureName]([procedureArgs] UserDoneCallback(request, done));
    }
})";

    replaceAll(str, "[paramsFromJsonArray]", paramsFromJsonArray);
    replaceAll(str, "[paramsFromJsonObject]", paramsFromJsonObject);
    replaceAll(str, "[stubProcedureName]", stubProcedureName);
    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[procedureArgs]", procedureArgs);
    return str;
}

std::string stubProcedureDefineTemplate(
        const std::string& stubProcedureName,
        const std::string& procedureName)
{
    std::string str =
R"(
void [stubProcedureName](json::Value& request, const RpcDoneCallback& done)
{
    convert().[procedureName](UserDoneCallback(request, done));
}
)";

    replaceAll(str, "[stubProcedureName]", stubProcedureName);
    replaceAll(str, "[procedureName]", procedureName);
    return str;
}

std::string stubNotifyDefineTemplate(
        const std::string& paramsFromJsonArray,
        const std::string& paramsFromJsonObject,
        const std::string& stubNotifyName,
        const std::string& notifyName,
        const std::string& notifyArgs)
{
    std::string str =
R"(
void [stubNotifyName](json::Value& request)
{
    auto& params = request["params"];

    if (params.isArray()) {
        [paramsFromJsonArray]
        convert().[NotifyName]([notifyArgs]);
    }
    else {
        [paramsFromJsonObject]
        convert().[NotifyName]([notifyArgs]);
    }
}
)";

    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[stubNotifyName]", stubNotifyName);
    replaceAll(str, "[notifyArgs]", notifyArgs);
    replaceAll(str, "[paramsFromJsonArray]", paramsFromJsonArray);
    replaceAll(str, "[paramsFromJsonObject]", paramsFromJsonObject);
    return str;
}

std::string stubNotifyDefineTemplate(
        const std::string& stubNotifyName,
        const std::string& notifyName)
{
    std::string str =
R"(
void [stubNotifyName](json::Value& request)
{
    convert().[notifyName]();
}
)";

    replaceAll(str, "[stubNotifyName]", stubNotifyName);
    replaceAll(str, "[notifyName]", notifyName);
    return str;
}

std::string argsDefineTemplate(
        const std::string& arg,
        const std::string& index,
        cppjson::ValueType type)
{
    std::string str = R"(auto [arg] = params[[index]][method];)";
    std::string method = [=](){
        switch (type) {
            case cppjson::TYPE_BOOL:
                return ".getBool()";
            case cppjson::TYPE_INT32:
                return ".getInt32()";
            case cppjson::TYPE_INT64:
                return ".getInt64()";
            case cppjson::TYPE_DOUBLE:
                return ".getDouble()";
            case cppjson::TYPE_STRING:
                return ".getString()";
            case cppjson::TYPE_OBJECT:
            case cppjson::TYPE_ARRAY:
                return "";//todo
            default:
                assert(false && "bad value type");
                return "bad type";
        }
    }();
    replaceAll(str, "[arg]", arg);
    replaceAll(str, "[index]", index);
    replaceAll(str, "[method]", method);
    return str;
}


}